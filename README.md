# Restaurant

#### by [Vasiliy Grachev](http://nasavasa.ru/)

Это система управления рестораном, разработанная на Kotlin с использованием Spring Boot. Она поддерживает два типа
пользователей: посетителей и администраторов. Система обрабатывает заказы в многопоточном режиме, позволяя клиентам
добавлять блюда в заказ во время обработки и просматривать статусы заказов. Администраторы могут управлять меню,
добавляя или удаляя блюда, а также устанавливая их количество, цену и сложность приготовления.

## Функциональности

1. **Аутентификация пользователей:**
    - Регистрация и вход в систему для пользователей.
    - Просмотр всех пользователей администраторами.
    - Выход из системы.

2. **Управление меню:**
    - Добавление новых блюд в меню администраторами.
    - Удаление блюд из меню администраторами.
    - Просмотр списка всех блюд (меню).

3. **Управление заказами:**
    - Клиенты могут создавать заказы, выбирая блюда из текущего меню.
    - Заказы обрабатываются в отдельных корутинах, симулируя процесс приготовления.
    - Клиенты могут добавлять блюда в существующий заказ во время его обработки.
    - Клиенты могут отменять заказ до его готовности.
    - Система отображает текущий статус каждого заказа ("принят (в обработке)", "готовится (в работе)", "готов", "отменён", "оплачен").
    - Клиенты могут оплатить свои заказы по завершении.
    - Клиенты могут оставлять отзывы о заказах после оплаты.
    - Клиенты могут посмотреть список своих заказов. Администраторы могут посмотреть список всех заказов.

4. **Просмотр статистики ресторана:**
    - Количество заказов и доходность.
    - Самые популярные блюда.
    - Заказы, отсортированные по рейтингу.
    - Средняя стоимость заказа.

5. **Health Check:**
    - Проверка доступности приложения.

6. **Ендпоинт для заполнения тестовыми данными:**
    - при вызове `/fill-mock-data` будет создан администратор, 2 посетителя, 10 случайных блюд.

## Структура проекта

Проект следует принципам ООП и принципам SOLID:

- `controllers`: Этот пакет содержит контроллеры, которые обрабатывают HTTP-запросы и ответы.
- `data/controllers`: Здесь находятся шаблоны запросов и ответов ко всем контроллерам.
- `data/enums`: Содержит перечисления (enums), определяющие набор константных значений.
- `data/interfaces`: Пакет с интерфейсами, которые определяют контракты для классов или компонентов.
- `data/models`: В этом пакете расположены классы данных, представляющие сущности (например, User, Dish, Order).
- `data/repositories`: Реализация шаблона репозитория для хранения и извлечения данных.
- `database`: Здесь хранятся JSON-файлы с данными.
- `services`: Пакет с классами, содержащими бизнес-логику для обработки действий пользователей и обработки заказов.
- `tools`: Содержит вспомогательные инструменты и утилиты.

Решение использовать JSON-файлы для хранения данных было принято, чтобы упростить выполнение задачи. Несмотря на это, в
проекте используется шаблон проектирования репозитория для управления данными.

## Начало работы

1. **Запуск приложения:**
    ```bash
    ./gradlew bootRun
    ```
2. **Открытие приложения:**
   перейдите в браузер по ссылке http://localhost:8080/swagger-ui/index.html

Убедитесь, что на вашей системе установлена и настроена JDK 17.

## Аутентификация

Система поддерживает аутентификацию как для посетителей, так и для администраторов. Посетители могут зарегистрироваться
в системе или войти, используя существующие учетные данные. Администраторы имеют дополнительные привилегии для
управления меню.

## Шаблоны проектирования

Проект использует различные шаблоны проектирования для обеспечения чистого и поддерживаемого кода:

- **MVC:** Применяется как главный паттерн для проектирования веб сервиса.
- **Шаблон репозитория:** Используется для доступа к данным и их хранения.
- **Одиночка (Singleton):** Применяется для хранения данных о ресторане.

## Многопоточность

Сервис `OrderProcessingService` предназначен для обработки заказов в многопоточном режиме. При поступлении нового заказа
метод `processOrder` добавляет его в очередь `orderQueue`. Затем метод `processNextOrder` запускается для обработки
следующего заказа в очереди.

Внутри метода `processNextOrder` каждый заказ обрабатывается в своей корутине. Сначала вычисляется общее время
приготовления заказа путем суммирования времени приготовления каждого блюда. Затем эмулируется приготовление с помощью
задержки `delay`. После завершения приготовления статус заказа обновляется, а прибыль ресторана также обновляется в
соответствии с ценой заказа.

Метод `cancel` используется для отмены обработки заказа, если он находится в процессе приготовления.

Сервис также использует семафор для контроля над доступными рабочими потоками. Изначальное значение семафора берется
из `application.properties`.

Система приоритетов: простая очередь (кто первый заказал, тот первый получит)

P.S. в требованиях указанно, что "посетители могут добавлять блюда в существующий заказ, пока он находится в обработке",
однако не обозначено, что именно считается обработкой. Так как я реализовал дополнительный функционал, ограничив
количество работников (количество работающих корутин), я посчитал, что "в обработке" значит статус "ACCEPTED", а "в
работе" значит статус "PREPARING".

